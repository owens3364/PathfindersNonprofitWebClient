{"ast":null,"code":"'use strict';\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src);\n\n    for (var i = 0, l = props.length; i < l; i++) {\n      dest[props[i]] = src[props[i]];\n    }\n  }\n\n  return dest;\n}\n\nfunction copy(obj) {\n  return extend({}, obj);\n}\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\n\n\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS);\n\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters);\n\n    for (var i = 0, l = chars.length; i < l; i++) {\n      var char = chars[i];\n\n      if (formatCharacters[char] == null) {\n        delete merged[char];\n      } else {\n        merged[char] = formatCharacters[char];\n      }\n    }\n  }\n\n  return merged;\n}\n\nvar ESCAPE_CHAR = '\\\\';\nvar DIGIT_RE = /^\\d$/;\nvar LETTER_RE = /^[A-Za-z]$/;\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/;\nvar DEFAULT_PLACEHOLDER_CHAR = '_';\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function validate(char) {\n      return ALPHANNUMERIC_RE.test(char);\n    }\n  },\n  '1': {\n    validate: function validate(char) {\n      return DIGIT_RE.test(char);\n    }\n  },\n  'a': {\n    validate: function validate(char) {\n      return LETTER_RE.test(char);\n    }\n  },\n  'A': {\n    validate: function validate(char) {\n      return LETTER_RE.test(char);\n    },\n    transform: function transform(char) {\n      return char.toUpperCase();\n    }\n  },\n  '#': {\n    validate: function validate(char) {\n      return ALPHANNUMERIC_RE.test(char);\n    },\n    transform: function transform(char) {\n      return char.toUpperCase();\n    }\n  }\n  /**\n   * @param {string} source\n   * @patam {?Object} formatCharacters\n   */\n\n};\n\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar);\n  }\n  /** Placeholder character */\n\n\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR;\n  /** Format character definitions. */\n\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS;\n  /** Pattern definition string with escape characters. */\n\n  this.source = source;\n  /** Pattern characters after escape characters have been processed. */\n\n  this.pattern = [];\n  /** Length of the pattern after escape characters have been processed. */\n\n  this.length = 0;\n  /** Index of the first editable character. */\n\n  this.firstEditableIndex = null;\n  /** Index of the last editable character. */\n\n  this.lastEditableIndex = null;\n  /** Lookup for indices of editable characters in the pattern. */\n\n  this._editableIndices = {};\n  /** If true, only the pattern before the last valid value character shows. */\n\n  this.isRevealingMask = isRevealingMask || false;\n\n  this._parse();\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('');\n  var patternIndex = 0;\n  var pattern = [];\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i];\n\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR);\n      }\n\n      char = sourceChars[++i];\n    } else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex;\n      }\n\n      this.lastEditableIndex = patternIndex;\n      this._editableIndices[patternIndex] = true;\n    }\n\n    pattern.push(char);\n    patternIndex++;\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error('InputMask: pattern \"' + this.source + '\" does not contain any editable characters.');\n  }\n\n  this.pattern = pattern;\n  this.length = pattern.length;\n};\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\n\n\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length);\n  var valueIndex = 0;\n\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask && value.length <= valueIndex && !this.isValidAtIndex(value[valueIndex], i)) {\n        break;\n      }\n\n      valueBuffer[i] = value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i) ? this.transform(value[valueIndex], i) : this.placeholderChar;\n      valueIndex++;\n    } else {\n      valueBuffer[i] = this.pattern[i]; // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++;\n      }\n    }\n  }\n\n  return valueBuffer;\n};\n/**\n * @param {number} index\n * @return {boolean}\n */\n\n\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index];\n};\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\n\n\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char);\n};\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]];\n  return typeof format.transform == 'function' ? format.transform(char) : char;\n};\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) {\n    return new InputMask(options);\n  }\n\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {\n      start: 0,\n      end: 0\n    },\n    value: ''\n  }, options);\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.');\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.');\n  }\n\n  this.placeholderChar = options.placeholderChar;\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters);\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  });\n} // Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\n\n\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end && this.selection.start === this.pattern.length) {\n    return false;\n  }\n\n  var selectionBefore = copy(this.selection);\n  var valueBefore = this.getValue();\n  var inputIndex = this.selection.start; // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex;\n  } // Bail out or add the character to input\n\n\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false;\n    }\n\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex);\n  } // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n\n\n  var end = this.selection.end - 1;\n\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar;\n    }\n\n    end--;\n  } // Advance the cursor to the next character\n\n\n  this.selection.start = this.selection.end = inputIndex + 1; // Skip over any subsequent static characters\n\n  while (this.pattern.length > this.selection.start && !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++;\n    this.selection.end++;\n  } // History\n\n\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex);\n\n    this._historyIndex = null;\n  }\n\n  if (this._lastOp !== 'input' || selectionBefore.start !== selectionBefore.end || this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({\n      value: valueBefore,\n      selection: selectionBefore,\n      lastOp: this._lastOp\n    });\n  }\n\n  this._lastOp = 'input';\n  this._lastSelection = copy(this.selection);\n  return true;\n};\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\n\n\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false;\n  }\n\n  var selectionBefore = copy(this.selection);\n  var valueBefore = this.getValue(); // No range selected - work on the character preceding the cursor\n\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar;\n    }\n\n    this.selection.start--;\n    this.selection.end--;\n  } // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n      var end = this.selection.end - 1;\n\n      while (end >= this.selection.start) {\n        if (this.pattern.isEditableIndex(end)) {\n          this.value[end] = this.placeholderChar;\n        }\n\n        end--;\n      }\n\n      this.selection.end = this.selection.start;\n    } // History\n\n\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex);\n  }\n\n  if (this._lastOp !== 'backspace' || selectionBefore.start !== selectionBefore.end || this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({\n      value: valueBefore,\n      selection: selectionBefore,\n      lastOp: this._lastOp\n    });\n  }\n\n  this._lastOp = 'backspace';\n  this._lastSelection = copy(this.selection);\n  return true;\n};\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\n\n\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection) // If there are static characters at the start of the pattern and the cursor\n    // or selection is within them, the static characters must match for a valid\n    // paste.\n\n  };\n\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false;\n      }\n    } // Continue as if the selection and input started from the editable part of\n    // the pattern.\n\n\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start);\n    this.selection.start = this.pattern.firstEditableIndex;\n  }\n\n  for (i = 0, l = input.length; i < l && this.selection.start <= this.pattern.lastEditableIndex; i++) {\n    var valid = this.input(input.charAt(i)); // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1;\n\n        if (!this.pattern.isEditableIndex(patternIndex) && input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue;\n        }\n      }\n\n      extend(this, initialState);\n      return false;\n    }\n  }\n\n  return true;\n}; // History\n\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false;\n  }\n\n  var historyItem;\n\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1;\n    historyItem = this._history[this._historyIndex]; // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n\n    var value = this.getValue();\n\n    if (historyItem.value !== value || historyItem.selection.start !== this.selection.start || historyItem.selection.end !== this.selection.end) {\n      this._history.push({\n        value: value,\n        selection: copy(this.selection),\n        lastOp: this._lastOp,\n        startUndo: true\n      });\n    }\n  } else {\n    historyItem = this._history[--this._historyIndex];\n  }\n\n  this.value = historyItem.value.split('');\n  this.selection = historyItem.selection;\n  this._lastOp = historyItem.lastOp;\n  return true;\n};\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false;\n  }\n\n  var historyItem = this._history[++this._historyIndex]; // If this is the last history item, we're done redoing\n\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null; // If the last history item was only added to start undoing, remove it\n\n    if (historyItem.startUndo) {\n      this._history.pop();\n    }\n  }\n\n  this.value = historyItem.value.split('');\n  this.selection = historyItem.selection;\n  this._lastOp = historyItem.lastOp;\n  return true;\n}; // Getters & setters\n\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {\n      start: 0,\n      end: 0\n    },\n    value: ''\n  }, options);\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask);\n  this.setValue(options.value);\n  this.emptyValue = this.pattern.formatValue([]).join('');\n  this.selection = options.selection;\n\n  this._resetHistory();\n};\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection);\n\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex;\n      return true;\n    } // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n\n\n    var index = this.selection.start;\n\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) && this.value[index - 1] !== this.placeholderChar || index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index;\n        break;\n      }\n\n      index--;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = '';\n  }\n\n  this.value = this.pattern.formatValue(value.split(''));\n};\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('');\n};\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = [];\n\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i]);\n    }\n  }\n\n  return rawValue.join('');\n};\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = [];\n  this._historyIndex = null;\n  this._lastOp = null;\n  this._lastSelection = copy(this.selection);\n};\n\nInputMask.Pattern = Pattern;\nmodule.exports = InputMask;","map":null,"metadata":{},"sourceType":"script"}